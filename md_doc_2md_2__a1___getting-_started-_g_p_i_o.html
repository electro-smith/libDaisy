<!-- HTML header for doxygen 1.9.2-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libDaisy: Getting Started - GPIO</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link rel="shortcut icon" type="image/x-icon" href="ES_Circle_Orange.PNG">
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo">
    <a href="index.html"><img alt="Logo" src="DaisyLogo.png"/></a>
  </td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libDaisy
   </div>
   <div id="projectbrief">Hardware Library for Daisy</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('md_doc_2md_2__a1___getting-_started-_g_p_i_o.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Getting Started - GPIO</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md1"></a></p>
<p>GPIO stands for General Purpose Input/Output. These are common to microcontrollers of all sizes, and are one of the many ways to work with external components.</p>
<p>GPIO are used as the basis for several interface components including switches, LEDs, encoders, etc.</p>
<p>The Daisy exposes several GPIO on its pinout. Most of these pins can do much more than just be a digital input or output, but we'll keep it simple for now.</p>
<p>Below, we'll discuss the code, hardware, and provide a few examples of how to use the GPIO within the Daisy ecosystem.</p>
<h1><a class="anchor" id="autotoc_md2"></a>
The CPP Objects Used</h1>
<p>We'll be using the <code>DaisySeed</code>, <code>Pin</code>, and <code>GPIO</code> objects in the following sections.</p>
<p>If you're using a different Daisy SOM (i.e. DaisyPatchSM, etc.) this still applies, but some of the pin names will be different.</p>
<p>The <code>DaisySeed</code> object is a class that manages all of the hardware on the Seed board. All we need to do with it for now is initialize it.</p>
<p>The <code>Pin</code> class is used to describe a specific physical pin on the hardware. These objects are used to initialize GPIO, but are also used in the configuration of more complex peripherals and devices (i.e. ADCs, Shift Registers, etc.).</p>
<p>The <code>GPIO</code> class is used for the basic reading/writing of a digital signal.</p>
<p>When we talk about "digital" signals, we mean a signal that has only two states, HIGH and LOW.</p>
<h1><a class="anchor" id="autotoc_md3"></a>
The Hardware Connections</h1>
<p>For the examples below we'll be using a few components. These can be replaced with a number of similar alternatives.</p>
<ul>
<li><a href="https://www.electro-smith.com/parts/pushbuttons">Mini Pushbutton</a></li>
<li><a href="https://www.electro-smith.com/parts/3mm-leds">3mm LED</a></li>
<li>Resistor(s) any low value (1-10K should work okay in the examples discussed below)</li>
</ul>
<h1><a class="anchor" id="autotoc_md4"></a>
GPIO Input</h1>
<p>One of the simplest uses of a GPIO is to read the state of a button.</p>
<p>For this example we'll use a simple <a href="https://www.electro-smith.com/parts/pushbuttons">mini pushbutton</a> to read the state of a button.</p>
<p>The easiest way to wire up a switch like this is to connect one set of legs (pins 1 and 2) to the GPIO input, and connect the other two legs (pins 3 and 4) to GND.</p>
<p>A very short example of a program to do this looks like:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="daisy__seed_8h.html">daisy_seed.h</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacedaisy.html">daisy</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacedaisy_1_1seed.html">daisy::seed</a>;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classdaisy_1_1_daisy_seed.html">DaisySeed</a> hw;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>) {</div>
<div class="line">  <span class="comment">// Initialize the Daisy Seed</span></div>
<div class="line">  hw.<a class="code hl_function" href="classdaisy_1_1_daisy_seed.html#a218cbf64aa64572a1b5bbc57fd00c895">Init</a>();</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Create a GPIO object</span></div>
<div class="line">  <a class="code hl_class" href="classdaisy_1_1_g_p_i_o.html">GPIO</a> my_button;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Initialize the GPIO object</span></div>
<div class="line">  my_button.<a class="code hl_function" href="classdaisy_1_1_g_p_i_o.html#ae576cffc1eef8b59d6cc2142cf1d9f97">Init</a>(D0, GPIO::Mode::INPUT, GPIO::Pull::PULLUP);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">while</span>(1) {</div>
<div class="line">    <span class="comment">// And let&#39;s store the state of the button in a variable called &quot;button_state&quot;</span></div>
<div class="line">    <span class="keywordtype">bool</span> button_state = my_button.<a class="code hl_function" href="classdaisy_1_1_g_p_i_o.html#a7671cd340ee06976816c354b5dd4f8a4">Read</a>();</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="ttc" id="aclassdaisy_1_1_daisy_seed_html"><div class="ttname"><a href="classdaisy_1_1_daisy_seed.html">daisy::DaisySeed</a></div><div class="ttdoc">This is the higher-level interface for the Daisy board.   All basic peripheral configuration/initiali...</div><div class="ttdef"><b>Definition</b> daisy_seed.h:19</div></div>
<div class="ttc" id="aclassdaisy_1_1_daisy_seed_html_a218cbf64aa64572a1b5bbc57fd00c895"><div class="ttname"><a href="classdaisy_1_1_daisy_seed.html#a218cbf64aa64572a1b5bbc57fd00c895">daisy::DaisySeed::Init</a></div><div class="ttdeci">void Init(bool boost=false)</div></div>
<div class="ttc" id="aclassdaisy_1_1_g_p_i_o_html"><div class="ttname"><a href="classdaisy_1_1_g_p_i_o.html">daisy::GPIO</a></div><div class="ttdoc">General Purpose I/O control.</div><div class="ttdef"><b>Definition</b> gpio.h:22</div></div>
<div class="ttc" id="aclassdaisy_1_1_g_p_i_o_html_a7671cd340ee06976816c354b5dd4f8a4"><div class="ttname"><a href="classdaisy_1_1_g_p_i_o.html#a7671cd340ee06976816c354b5dd4f8a4">daisy::GPIO::Read</a></div><div class="ttdeci">bool Read()</div><div class="ttdoc">Reads the state of the GPIO.</div></div>
<div class="ttc" id="aclassdaisy_1_1_g_p_i_o_html_ae576cffc1eef8b59d6cc2142cf1d9f97"><div class="ttname"><a href="classdaisy_1_1_g_p_i_o.html#ae576cffc1eef8b59d6cc2142cf1d9f97">daisy::GPIO::Init</a></div><div class="ttdeci">void Init()</div><div class="ttdoc">Initialize the GPIO using the internal Config struct.</div></div>
<div class="ttc" id="adaisy__seed_8h_html"><div class="ttname"><a href="daisy__seed_8h.html">daisy_seed.h</a></div></div>
<div class="ttc" id="anamespacedaisy_1_1seed_html"><div class="ttname"><a href="namespacedaisy_1_1seed.html">daisy::seed</a></div><div class="ttdef"><b>Definition</b> daisy_seed.h:196</div></div>
<div class="ttc" id="anamespacedaisy_html"><div class="ttname"><a href="namespacedaisy.html">daisy</a></div><div class="ttdoc">Hardware defines and helpers for daisy field platform.</div><div class="ttdef"><b>Definition</b> index.h:2</div></div>
</div><!-- fragment --><p>If you haven't followed the guides on <a href="https://github.com/electro-smith/DaisyWiki/wiki/1.-Setting-Up-Your-Development-Environment">setting up your development environment</a> and <a href="https://github.com/electro-smith/DaisyWiki/wiki/How-To:-Create-a-New-Project">creating a new project</a> now would be a perfect time to catch up, and create a new project to work with the GPIO.</p>
<p>Compiling this example, you might get a warning, for an "unused variable button_state", but we'll get to using that shortly!</p>
<h1><a class="anchor" id="autotoc_md5"></a>
Breaking Down the Init function</h1>
<p>Let's look at that GPIO init function in a bit more detail, shall we? First, we'll breakdown the full Initialization definition:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> Init(<a class="code hl_struct" href="structdaisy_1_1_pin.html">Pin</a> p, Mode m=Mode::INPUT, Pull pu=Pull::NOPULL, Speed sp=Speed::LOW);</div>
<div class="ttc" id="astructdaisy_1_1_pin_html"><div class="ttname"><a href="structdaisy_1_1_pin.html">daisy::Pin</a></div><div class="ttdoc">representation of hardware port/pin combination</div><div class="ttdef"><b>Definition</b> daisy_core.h:193</div></div>
</div><!-- fragment --><p>The first thing you may be wondering, if you're not used to C++ is the <code>::</code> characters all over the place. These are used for the configuration settings so that the compiler will only allow you to use the correct inputs instead of being able to pass the wrong thing to the input, or even just mis-order the arguments, and end up scratching your head for hours wondering what's not working.</p>
<p>These <code>::</code> are also used for namespaces, which we handle in the above example with the <code>using namespace</code> lines. Without that we'd have to use <code><a class="el" href="classdaisy_1_1_g_p_i_o.html" title="General Purpose I/O control.">daisy::GPIO</a></code> instead of <code>GPIO</code>, <code><a class="el" href="namespacedaisy_1_1seed.html#a1796c1ab85923482d0278dc7e25cfbf7">daisy::seed::D0</a></code> instead of <code>D0</code>, etc.</p>
<h2><a class="anchor" id="autotoc_md6"></a>
Pin Argument</h2>
<p>So, the first argument: <code>Pin p</code> describes the daisy pin to assign to our GPIO, this ties our new GPIO object to some of the actual hardware on the Daisy Seed. By using <code>D0</code> (or more explicitly, <code><a class="el" href="namespacedaisy_1_1seed.html#a1796c1ab85923482d0278dc7e25cfbf7">daisy::seed::D0</a></code>), we're saying we want to use that pin for our GPIO.</p>
<h2><a class="anchor" id="autotoc_md7"></a>
Mode Argument</h2>
<p>The second argument: <code>Mode m</code> can be any of the following:</p>
<ul>
<li><code>Mode::INPUT</code> - configures the pin as an input</li>
<li><code>Mode::OUTPUT</code> - configures the pin as an output (in push pull configuration)</li>
<li><code>Mode::OPEN_DRAIN</code> - also an output, but the transistor connection to pull the signal to GND is not connected, this is less commonly used.</li>
<li><code>Mode::ANALOG</code> - configures the GPIO for connection to the ADC or DAC peripherals within the micro controller.</li>
</ul>
<p>If you only supply the <code>Pin</code> argument, the GPIO will default to <code>Mode::INPUT</code> configuration.</p>
<h2><a class="anchor" id="autotoc_md8"></a>
Pull Argument</h2>
<p>The third argument: <code>Pull pu</code> is used to select whether the GPIO will use an internal (around 30-50k) resistor as a pull up or pull down resistor.</p>
<p>A pull up resistor will keep the GPIO idling at 3V3 unless something pulls it down, while a pull down resistor will keep a GPIO idling at 0V unless something pulls it up.</p>
<p>The options for this argument are:</p>
<ul>
<li><code>Pull::NOPULL</code> - no pull up or pull down resistor is connected.</li>
<li><code>Pull::PULLUP</code> - pull up resistor is connected to the GPIO line.</li>
<li><code>Pull::PULLDOWN</code> - pull down resistor is connected to the GPIO line.</li>
</ul>
<p>This argument will default to <code>Pull::NOPULL</code> if you only supply a <code>Pin</code> and a <code>Mode</code></p>
<p>So when, and why do we need pull up or pull down resistors anyway?</p>
<p>Well, if we connect a wire to one of Daisy's GPIO pins, and there are no internal or external resistors attached, there's no definite way to know what voltage the wire is sitting at.</p>
<p>Now, if we connect the wire to a button, as we did in the above example, and connect the other side of the button to 3V3 then we <em>do</em> know the voltage at the pin when the button pressed. However, when the button is not pressed, we still have an "undefined" state, as we can't guarantee that the pin will be at 0V when the button isn't pressed.</p>
<p>To solve this unknown state issue, we can add a resistor to the pin that "pulls" the signal to GND when the button isn't actively pulling the voltage up to 3V3 (while pressed).</p>
<p>Instead of adding an external resistor to do this, we can use the built-in pull-down feature to accomplish the same thing.</p>
<p>In the example above, we did the same thing except we used the pull up resistor, and wired the button to GND. This usually just requires less wires, but the function is the same.</p>
<h2><a class="anchor" id="autotoc_md9"></a>
Speed Argument</h2>
<p>The final argument, <code>Speed sp</code> is a special configuration for Output modes that control the slew rate, or the speed at which it can switch from 0V to 3V. We won't go super in depth on that in this, but you'll always want it to be the lowest speed possible for a given application to reduce the amount of electrical noise emitted.</p>
<h1><a class="anchor" id="autotoc_md10"></a>
GPIO Output</h1>
<p>So you've got your button reading code, your board wired up, and you're probably thinking, "Great! So how can I tell if I've done this correctly!?".</p>
<p>Well, let's set up a second pin as an output to light up an LED when we push our button. That way we can tell everything we've done so far is working.</p>
<p>Setting up the GPIO output isn't much more work.</p>
<p>On your hardware, you'll want to take the second pin (right above the square D0 pin), and connect a resistor, and an LED in series. You'll want the <b>cathode</b> of the LED connected to GND, with the <b>anode</b> connected to the resistor, <a href="https://makecode.adafruit.com/learnsystem/pins-tutorial/devices/led-connections">as described here</a>.</p>
<p>Once you've got that set up we can add a few lines to our example.</p>
<p>In the Initialization section:</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classdaisy_1_1_g_p_i_o.html">GPIO</a> my_led;</div>
<div class="line"> </div>
<div class="line">my_led.<a class="code hl_function" href="classdaisy_1_1_g_p_i_o.html#ae576cffc1eef8b59d6cc2142cf1d9f97">Init</a>(D1, GPIO::Mode::OUTPUT);</div>
</div><!-- fragment --><p>And then we can use the <code>button_state</code> variable we were reading from the button earlier to control the state of the LED:</p>
<div class="fragment"><div class="line"><span class="keywordflow">while</span>(1)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// And let&#39;s store the state of the button in a variable called &quot;button_state&quot;</span></div>
<div class="line">  <span class="keywordtype">bool</span> button_state = my_button.<a class="code hl_function" href="classdaisy_1_1_g_p_i_o.html#a7671cd340ee06976816c354b5dd4f8a4">Read</a>();</div>
<div class="line">  my_led.<a class="code hl_function" href="classdaisy_1_1_g_p_i_o.html#a2cff092b5e71cd8a2baccfbdc5ee8584">Write</a>(button_state);</div>
<div class="line">}</div>
<div class="ttc" id="aclassdaisy_1_1_g_p_i_o_html_a2cff092b5e71cd8a2baccfbdc5ee8584"><div class="ttname"><a href="classdaisy_1_1_g_p_i_o.html#a2cff092b5e71cd8a2baccfbdc5ee8584">daisy::GPIO::Write</a></div><div class="ttdeci">void Write(bool state)</div><div class="ttdoc">Changes the state of the GPIO hardware when configured as an OUTPUT.</div></div>
</div><!-- fragment --><p>And that's it! Easy, right?</p>
<p>So you get that all set up, and you might be thinking, "Well, this is great, but the LED turns off when I push the button instead of turning it on, what the heck?"</p>
<p>That's because of the way we set up the button in the first step. Because we used the internal pull up resistor, to avoid adding extra parts to our board, the GPIO is returning true while the button is not pressed instead of what we might expect. Well, C++ has a very easy way of flipping that over.</p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> button_state = my_button.<a class="code hl_function" href="classdaisy_1_1_g_p_i_o.html#a7671cd340ee06976816c354b5dd4f8a4">Read</a>(); <span class="comment">// state is false while button is pressed</span></div>
<div class="line"><span class="keywordtype">bool</span> button_pressed = !button_state; <span class="comment">// &quot;!&quot; is a &quot;not&quot; operator, which will flip a bool var.</span></div>
</div><!-- fragment --><p>So all together, our short little light switch program will look something like:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="daisy__seed_8h.html">daisy_seed.h</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacedaisy.html">daisy</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacedaisy_1_1seed.html">daisy::seed</a>;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classdaisy_1_1_daisy_seed.html">DaisySeed</a> hw;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>) {</div>
<div class="line">  <span class="comment">// Initialize the Daisy Seed</span></div>
<div class="line">  hw.<a class="code hl_function" href="classdaisy_1_1_daisy_seed.html#a218cbf64aa64572a1b5bbc57fd00c895">Init</a>();</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Create our GPIO object</span></div>
<div class="line">  <a class="code hl_class" href="classdaisy_1_1_g_p_i_o.html">GPIO</a> my_button;</div>
<div class="line">  <a class="code hl_class" href="classdaisy_1_1_g_p_i_o.html">GPIO</a> my_led;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Initialize the GPIO object for our button */</span></div>
<div class="line">  my_button.<a class="code hl_function" href="classdaisy_1_1_g_p_i_o.html#ae576cffc1eef8b59d6cc2142cf1d9f97">Init</a>(D0, GPIO::Mode::INPUT, GPIO::Pull::PULLUP);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Initialize the GPIO object for our LED</span></div>
<div class="line">  my_led.<a class="code hl_function" href="classdaisy_1_1_g_p_i_o.html#ae576cffc1eef8b59d6cc2142cf1d9f97">Init</a>(D1, GPIO::Mode::OUTPUT);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">while</span>(1) {</div>
<div class="line">    <span class="comment">// And let&#39;s store the state of the button in a variable called &quot;button_state&quot;</span></div>
<div class="line">    <span class="keywordtype">bool</span> button_state = my_button.<a class="code hl_function" href="classdaisy_1_1_g_p_i_o.html#a7671cd340ee06976816c354b5dd4f8a4">Read</a>();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// And we want to light up the LED while we&#39;re pressing the button </span></div>
<div class="line">    <span class="comment">// so let&#39;s use the &quot;!&quot; to flip over the button_state</span></div>
<div class="line">    my_led.<a class="code hl_function" href="classdaisy_1_1_g_p_i_o.html#a2cff092b5e71cd8a2baccfbdc5ee8584">Write</a>(!button_state);</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md11"></a>
Further Reading</h1>
<p>Topics coming soon:</p>
<ul>
<li>Working with ADCs</li>
<li>Serial Printing over USB</li>
<li>Using the Switch and LED classes instead of GPIO, and Why? </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.2-->
<!-- start footer part -->
<div id="nav-path" class="navpath">
  <!-- id is needed for treeview function! -->
  <ul>
  </ul>
</div>
<script type="text/javascript">
  // script for doxygen 1.9.2
  $(function () {
    toggleButton = document.createElement('doxygen-awesome-dark-mode-toggle')
    toggleButton.title = "Toggle Light/Dark Mode"
    $(document).ready(function () {
      document.getElementById("MSearchBox").parentNode.appendChild(toggleButton)
    })
    $(window).resize(function () {
      document.getElementById("MSearchBox").parentNode.appendChild(toggleButton)
    })
  })
</script>
</body>
</html>
